--- drivers/input/touchscreen/atmel_224e.c
+++ drivers/input/touchscreen/atmel_224e.c
@@ -666,11 +663,10 @@
 	return count;
 }
 
-static DEVICE_ATTR(unlock, (S_IWUSR|S_IRUGO),
-	NULL, atmel_unlock_store);
+static DEVICE_ATTR(unlock, (S_IWUSR|S_IRUGO), NULL, atmel_unlock_store);
 
 static ssize_t atmel_info_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 	size_t count = 0;
 	count += sprintf(buf, "Type B/mtsize/new filter/INT\n");
@@ -935,48 +931,64 @@
 
 		if (ts->grip_suppression & BIT(idx))
 			ts->grip_suppression &= ~BIT(idx);
-		if (ts->finger_pressed & BIT(idx)) {
-			if (!ts->finger_count)
-				printk(KERN_ERR "[TP]TOUCH_ERR: finger count has reached zero\n");
-			else
-				ts->finger_count--;
-			ts->finger_pressed &= ~BIT(idx);
-			if (!ts->first_pressed) {
-				if (!ts->finger_count)
-					ts->first_pressed = 1;
-				printk(KERN_INFO "[TP]E%d@%d,%d\n",
-					idx + 1, ts->finger_data[idx].x, ts->finger_data[idx].y);
-			}
-			if (ts->pre_data[0] < RECALIB_DONE) {
-				if (ts->finger_count == 0) {
-					if (ts->pre_data[0] == RECALIB_NEED &&
-						!ts->unlock_attr && idx == 0 &&
-						ts->finger_data[idx].y > 750 &&
-						ts->finger_data[idx].y - ts->pre_data[idx+1] > 135) {
-							restore_normal_threshold(ts);
-							confirm_calibration(ts, 1, 0);
-					} else if (ts->pre_data[0] == RECALIB_UNLOCK &&
-						ts->unlock_attr && idx == 0 &&
+		if (!(ts->finger_pressed & BIT(idx)))
+			/* end since finger was not pressed */
+			return;
+
+		if (ts->report_type == SYN_AND_REPORT_TYPE_B) {
+			input_mt_slot(ts->input_dev, idx);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+			input_sync(ts->input_dev);
+		}
+
+		if (ts->finger_count == 0)
+			printk(KERN_ERR "[TP]TOUCH_ERR: finger count has reached zero\n");
+		else
+			ts->finger_count--;
+		ts->finger_pressed &= ~BIT(idx);
+
+		if (!ts->first_pressed) {
+			if (ts->finger_count == 0)
+				ts->first_pressed = 1;
+			printk(KERN_INFO "[TP]E%d@%d,%d\n",
+				idx + 1, ts->finger_data[idx].x, ts->finger_data[idx].y);
+		}
+
+		switch (ts->pre_data[0]) {
+			case RECALIB_NEED:
+				if (ts->finger_count == 0 && !ts->unlock_attr && idx == 0) {
+					/* recalibrate on last release */
+					restore_normal_threshold(ts);
+					confirm_calibration(ts, 1, 0);
+				}
+				break;
+			case RECALIB_UNLOCK:
+				if (ts->finger_count) {
+					i2c_atmel_write_byte_data(ts->client,
+						get_object_address(ts, GEN_COMMANDPROCESSOR_T6) +
+						T6_CFG_CALIBRATE, 0x55);
+				} else if (ts->unlock_attr && idx == 0 &&
 						time_after(jiffies, ts->valid_press_timeout)) {
-						ts->valid_pressed_cnt++;
-						if (ts->pre_data[0] == RECALIB_UNLOCK &&
-							ts->valid_pressed_cnt > 2) {
-							cancel_delayed_work_sync(&ts->unlock_work);
-							if (ts->pre_data[0] == RECALIB_UNLOCK)
-								confirm_calibration(ts, 0, 1);
-						}
-					} else if (ts->pre_data[0] == RECALIB_NG)
-						ts->pre_data[0] = RECALIB_NEED;
-				} else {
-					if (ts->pre_data[0] < RECALIB_UNLOCK)
-						i2c_atmel_write_byte_data(ts->client,
-							get_object_address(ts, GEN_COMMANDPROCESSOR_T6) +
-							T6_CFG_CALIBRATE, 0x55);
+					ts->valid_pressed_cnt++;
+					if (ts->valid_pressed_cnt > 2) {
+						cancel_delayed_work_sync(&ts->unlock_work);
+						confirm_calibration(ts, 0, 1);
+					}
 				}
-			}
+				break;
+			case RECALIB_NG:
+				if (ts->finger_count == 0)
+					ts->pre_data[0] = RECALIB_NEED;
+				break;
+			default:
+				break;
+
 		}
-	} else if ((data[T9_MSG_STATUS] & (T9_MSG_STATUS_DETECT|T9_MSG_STATUS_PRESS)) &&
-		!(ts->finger_pressed & BIT(idx))) {
+	} else if (data[T9_MSG_STATUS] & (T9_MSG_STATUS_DETECT|T9_MSG_STATUS_PRESS)) {
+		if (ts->finger_pressed & BIT(idx))
+			/* end since finger is already pressed */
+			return;
+
 		if (ts->filter_level[0]) {
 			if (ts->finger_data[idx].x < ts->filter_level[FL_XLOGRIPMIN] ||
 				ts->finger_data[idx].x > ts->filter_level[FL_XHIGRIPMAX])
@@ -1524,7 +1541,7 @@
 	printk(KERN_INFO "[TP]cable change to %d\n", connect_status);
 
 	if (connect_status != ts->status) {
-			ts->status = connect_status > 0 ? CONNECTED : NONE;
+		ts->status = connect_status ? CONNECTED : NONE;
 			printk(KERN_INFO "[TP]ts->status change to %d\n", ts->status);
 		if (!ts->status && ts->wlc_status)
 			printk(KERN_ERR "[TP]TOUCH_ERR:ambigurous wireless charger state\n");
